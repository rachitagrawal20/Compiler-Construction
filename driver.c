// BATCH NUMBER 6
// PRASHANT KHANDELWAL 2016B4A70930P
// NAMAN DEEP SRIVASTAVA 2016B4A70891P
// RACHIT AGRAWAL 2016B2A70901P
// MOHIT KRIPLANI 2016B1A70870P
// UTKARSH AGARWAL 2016B3A70581P

/*
This file contains driver code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "lexer.h"
#include "parser.h"
#include "helper.h"
#include "ast.h"
#include "symbolTable.h"
#include "typeChecker.h"
#include "semanticanalyzer.h"
#include "codegen.h"

void printFile(char *fileName){
	FILE *fptr = fopen(fileName, "r");
	char c;
	c = fgetc(fptr); 
    while (c != EOF) 
    { 
        printf ("%c", c); 
        c = fgetc(fptr); 
    } 
  
    fclose(fptr); 
}

int main(int argc, char const *argv[])
{ 
 				
	int in;
	char *line = NULL;
	char *testcaseFile = (char *) argv[1];
	char *asmCodeFile = (char *) argv[2];
	char *parseTreeOutFile = "treeOutput.txt";
	char *cleanFile = "cleanFile.txt";

	clock_t start_time, end_time;
	double total_CPU_time, total_CPU_time_in_seconds;

	size_t len = 0;
	
	readSymbolTable();

	FILE *fp = NULL;
	Grammar *G = NULL;
	FirstAndFollow *F = NULL;
	ParseTable *T = NULL;
	TreeNode *PT = NULL;
	
	printf("\n----------Implementation Status----------\n");
	printf("a. FIRST and FOLLOW sets automated.\n"); 
	printf("b. Both lexical and syntax analysis modules implemented and working successfully.\n");	
	printf("c. Modules are working with all provided testcases.\n");	
	printf("d. Parse tree is constructed and printed in the output file as desired.\n\n");

	while(1){

		fp = NULL;
		G = NULL;
		F = NULL;
		T = NULL;
		PT = NULL;

		printf("\n----------Press option for the defined task----------\n");
		printf("1 : For printing the token list generated by the lexer\n");
		printf("2 : For parsing to verify the syntactic correctness of the input source code and to produce parse tree\n");
		printf("3 : For printing the Abstract Syntax Tree in appropriate format. Also specify the traversal order at the beginning\n");
		printf("4 : For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used\n");		
		printf("5 : For printing the Symbol Table\n");
		printf("6 : For printing the total memory requirement for each function\n");
		printf("7 : For printing the type expressions and width of array variables in a line for a test case\n");
		printf("8 : For verifying the syntactic and semantic correctness of the input source code and printing the total compiling time\n");
		printf("9 : For producing assembly code\n");		
		printf("0 : Exit\n");

		scanf("%d", &in);
		switch(in)
		{
			case 1:
					// For printing the token list generated by the lexer (on the console)
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);
					printTokenList();	
	 				break;
			
			case 2:
					// For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console)
					
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);

					if(error == 0){
						printf("Code is syntactically correct and parse tree printed in %s.\n", parseTreeOutFile);
						printTree(PT, parseTreeOutFile);
						printFile(parseTreeOutFile);
					} else {
						printf("Code is syntactically not correct & hence parse tree can't be printed.\n");
					}
					break;
			
			case 3: 
					// For printing the Abstract Syntax Tree in appropriate format. Also specify the traversal order at the beginning. (On Console)
					
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);
					
					if(error == 0){
						generateAst(PT);
						printf("INORDER traversal of AST follows:\n");
						printTree(PT, parseTreeOutFile);
						printFile(parseTreeOutFile);
					} else {
						printf("Code is syntactically not correct & hence abstract syntax tree can't be printed.\n");
					}
					break;

			case 4: 
					// For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used
					
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);
					
					if(error == 0){
						int parseTreeNodeCount = printTree(PT, parseTreeOutFile);
						generateAst(PT);
						int ASTNodeCount = printTree(PT, parseTreeOutFile);
						printf("Parse tree     Number of nodes = %d Allocated Memory = %lu Bytes\n", parseTreeNodeCount, parseTreeNodeCount*sizeof(TreeNode));
						printf("AST            Number of nodes = %d Allocated Memory = %lu Bytes\n", ASTNodeCount, ASTNodeCount*sizeof(TreeNode));
						printf("Compression percentage = %lf\n",(parseTreeNodeCount-ASTNodeCount)*100.0/parseTreeNodeCount);
					}else{
						printf("Code is syntactically not correct.\n");
					}
					break;

			case 5: 
					// For printing the Symbol Table giving information (ten in number) for each variable identifier at each line using formatted output
					
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);

					// symbol table
					if(error == 0){	
						buildSymbolTable(PT);
						printSymbolTable2(PT);
						if(semanticError == 0){
						}else{
							puts("Symbol Table can't be printed since there are semantic errors as follows:");
							deficit_errors();
							printSymbolTableErrors();
						}
					}else{
						puts("Symbol Table can't be printed since there are syntactical errors");
					}
					break;

			case 6:
					// For printing the total memory requirement for each function

					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);

					// symbol table
					if(error == 0){	
						buildSymbolTable(PT);
						if(semanticError == 0){
							// printSymbolTable2(PT);
							printScope(PT);

						}else{
							puts("Cannot print scope since there are semantic errors as follows:");
							deficit_errors();
							printSymbolTableErrors();
						}
					}else{
						puts("Cannot print scope since there are syntactical errors");
					}
					break;

			case 7:
					// For printing the type expressions and width of array variables in a line for a test case
					
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);

					// symbol table
					if(error == 0){	
						buildSymbolTable(PT);
						if(semanticError == 0){
							// printSymbolTable2(PT);
							printArrayInfo(PT);

						}else{
							puts("Cannot print array variables' information since there are semantic errors as follows:");
							deficit_errors();
							printSymbolTableErrors();
						}
					}else{
						puts("Cannot print array variables' information since there are syntactical errors");
					}
					break;

			case 8: 
					// Errors reporting and total compiling time
					
					start_time = clock();
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);
					
					if(error == 0)
					{	
						puts("No Syntactic Errors");
						puts("Semantic errors, if any follow:");
						buildSymbolTable(PT);
						deficit_errors();
						printSymbolTableErrors();	
						generateAst(PT);
						printTree(PT, parseTreeOutFile);
						typeCheck(PT);
						semanticAnalyzer(PT);
						if(semanticError == 0)
							puts("Code compiles successfully..........\n");
						else
							semanticError=0;
					}
					else{
						puts("\nCode is syntactically not correct.\n");
					}
					end_time = clock();

					total_CPU_time = (double) (end_time-start_time);
					total_CPU_time_in_seconds = total_CPU_time/CLOCKS_PER_SEC;

					printf("\nTime taken by Compiler:\n\tTotal CPU time:\t%f\n\tTotal CPU time in seconds:\t%f\n", total_CPU_time, total_CPU_time_in_seconds);

					break;

			case 9: 
					//lexing
					removeComments(testcaseFile, cleanFile);
					fp = fopen(cleanFile, "r");
					fp = getStream(fp);
					fclose(fp);

					//parsing
	    			G = readGrammar();
	    			// printGrammar(G, "generated/initialLinkedGrammar.txt");
	    			// writeHashTables();

					F = (FirstAndFollow *) malloc(sizeof(FirstAndFollow));
					ComputeFirstAndFollowSets(G, F);
					// printFirstAndFollowSet(F, "generated/firstSets.txt", "generated/followSets.txt");

					T = (ParseTable *) malloc(sizeof(ParseTable));
					createParseTable(G, F, T);
					// printParseTable(T, "generated/parseTable.txt"); 	

					PT = parseInputSourceCode(G, T, F);
					
					if(error == 0)
					{	
						puts("No Syntactic Errors");
						puts("Semantic errors, if any follow:");
						buildSymbolTable(PT);
						deficit_errors();
						printSymbolTableErrors();	
						generateAst(PT);
						printTree(PT, parseTreeOutFile);
						typeCheck(PT);
						semanticAnalyzer(PT);
						if(semanticError == 0){
							puts("Code compiles successfully..........\n");
							codeGenerator(PT, asmCodeFile);
						}
					}
					break;

			case 0:
					// To exit from the loop (Ask for the choices in a loop)
					exit(1);
					break;

			default:
					printf("Please enter a suitable option\n");
		}
		free(G);
		free(F);
		free(T);
		free(PT);
	}
	return 0;
}
